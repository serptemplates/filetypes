{
  "type": "application",
  "subtype": "applefile",
  "full": "application/applefile",
  "extensions": [],
  "sources": [
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    },
    {
      "source": "iana",
      "url": "https://www.iana.org/assignments/media-types/media-types.xhtml"
    },
    {
      "source": "apache",
      "url": "https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types"
    },
    {
      "source": "nginx",
      "url": "https://hg.nginx.org/nginx/raw-file/default/conf/mime.types"
    },
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    }
  ],
  "iana": {
    "template_url": "https://www.iana.org/assignments/media-types/application/applefile",
    "template_text": "\n\nMacMIME - How to send Macintosh files with MIME\n\n\n\n\n\n       MacMIME - How to send Macintosh files with MIME\n                              \n                              \n                              \n                    Sun Mar 14 22:07 1993\n                              \n                              \n                              \n                     Patrik Faeltstroem\n                              \n   Department of Numerical Analysis and Computing Science\n                              \n                Royal Institute of Technology\n                              \n                       paf&nada.kth.se\n                              \n\n\n\n\n1.  Status of this Memo\n\nThis draft document will be submitted to the Internet\nActivities Board as a standards document. As this is a\nworking document only, it should neither be cited nor quoted\nin any formal document. Distribution of this memo is\nunlimited. Please send comments to\n<ietf-822&dimacs.rutgers.edu>.\n\n\n\n2. Abstract\n\nThis memo describes how to specify a message format based on\nRFC-1341 [1], to allow the transportation of Macintosh files.\nThe solution proposed is designed to be highly compatible\nwith existing mechanisms for distributing Macintosh files,\nand it should be readily implementable in mail readers that\nsupport RFC-1341.\n\n\n\n3. Introduction\n\nFiles on the Macintosh consists of two parts, called forks:\n\n    DATA:\n    \n         The actual data included in the file. This is a\n         series of consecutive bytes of data, often seen as\n         corresponding to an entire file in some other\n         operating systems.\n         \n\n\n    RESOURCE:\n    \n         Contains a collection of arbitrary attribute/value\n         pairs, including program segments, icon bitmaps,\n         and parametric values.\n         \n\n\nBesides these two, there is some additional information which\nthe Finder has in its \"Desktop Database\", and this info can\nsometimes be regarded as a third part of the file.\n\nBecause of the lack of possibilities for storing different\nparts of the same file in a filesystem that only handles\nconsecutive data in one part, it is common to pack, or\nconvert, the Macintosh file into some other format before\nmoving the file over the network.\n\nFormats accepted are:\n\n    AppleSingle [2]    A representation of Macintosh files\n                   as one consecutive stream of bytes,\n                   invented and used by Apple (see appendix\n                   A).\n                   \n    AppleDouble [2]    A special version of AppleSingle\n                   where the Data fork of the document is\n                   separated from the other parts included in\n                   AppleSingle (see appendix A).\n                   \n    BinHex        A representation widely used in the\n                   Macintosh community. However, the BinHex\n                   encoding should not be the primary format.\n                   It is defined and accepted to provide\n                   backward compatibility (see point 6 and\n                   appendix B).\n                   \nIt might look strange to define three different formats, but\nit isn't. All three formats has it's pros and it's cons.\n\nThe AppleDouble format should be the primary format when\nsending a Macintosh document. It makes it possible for a user\nthat can't decode the AppleDouble header to read and use the\nData fork of the document. It also keep the Macintosh\nspecific information in the AppleDouble header, so a user who\ncan decode the AppleDouble header can get the extra in\nformation, such as customised icons, which is not essential\nto the document itself.\n\nOne disadvantage is though that the AppleDouble format is two\nparallel streams of bytes. That means that a user who has to\ncreate the MIME document by hand, or move and store the file\ntemporarily when creating the MIME message, has to handle two\nfiles. If the receiver is known to have a Macintosh, or the\ndata is Macintosh specific (such as an application) it might\nbe more convenient to use the AppleSingle format. The\nAppleSingle format is one stream of bytes only, but the\nformat is exactly the same as the AppleDouble header, so an\napplication that can decode the AppleDouble format should\nalso be able to decode the AppleSingle format.\n\nBut, neither AppleSingle nor AppleDouble does contain a CRC\n(Cyclic Redundancy Code) which can help to detect\ntransmission errors. BinHex4.0 does contain such codes, both\nfor the Data and Resource fork. Also, the BinHex4.0 format is\none of the formats most widely used today on public file\nservers when storing Macintosh files in printable ASCII\nformat. With that as a background, a subtype for the\nBinHex4.0 format is defined. It should though only be used in\nsome special cases, for backward compatibility, and then only\nas a replacement for the AppleSingle format, i.e. just for\nsending Macintosh specific data, or to other Macintosh users.\n\nConclusion: The AppleDouble format should be the primary\nformat used, even though both AppleSingle and BinHex4.0 is\naccepted. A minimal MacMIME-aware mail reader is able to\nencode and decode the AppleSingle and Apple Double formats.\nThe BinHex4.0 format is to be recognised so the file can be\nsaved and later decoded with another program.\n\n\n\n4. Syntax\n\nThis document describes some additional subtypes of the types\nlisted in RFC-1341.\n\nThe new subtypes added are:\n\n    application/applefile Part 5.1 and 5.2\n    \n    multipart/appledouble Part 5.2\n    \nFor backward compatibility with non-MIME aware mail programs\na subtype for the very wide-spread encoding of Macintosh\nfiles, BinHex 4.0:\n\n     application/mac-binhex40    Part 7.1\n    \n\n\n5. Representation\n\n\n\n5.1 AppleSingle\n\nAn AppleSingle, version 2 file, is sent as one consecutive\nstream of bytes. The format is described in\n\"AppleSingle/AppleDouble Formats for Foreign Files\nDeveloper's Note\" [2]. The one and only part of the file is\nsent in an application/applefile message.\n\nThe first four bytes of an AppleSingle header is, in\nhexadecimal: 00, 05, 16, 00.\n\nThe AppleSingle file is binary data. Hence, it may be\nnecessary to perform a Content-Transfer-Encoding for\ntransmission. The safest encoding is Base64, since it permits\ntransfer over the most limited media.\n\nAn AppleSingle file includes the original Macintosh filename,\nso the filename used when storing the file on a foreign\nfilesystem is of no importance. But, to give a hint to the\nreceiver what file is sent, a parameter called name can be\nused. The value of this parameter must be in such character\nset so it's accepted according to the rules in RFC-1341 [1].\n\nThe AppleSingle file also includes the original Macintosh\nfile type, but to give a hint to the receiver what type of\nfile is sent, a parameter called type can be used. The value\nof this parameter should be human readable, and in such\ncharacter set so it's accepted according to the rules in RFC-\n1341 [1].\n\n\n\n5.2 AppleSingle example\n\n  Content-Type: application/applefile; name=\"New Computers\n  1/2 -93\"; type=\"MSWord5.1a\"\n  \n      [The AppleSingle file follows (starts with, in\n  hexadecimal: 00051600)]\n\n\n5.3 AppleDouble\n\nAn AppleDouble, version 2, file is divided in two parts, a\nheader and a data block. Both of these are described in\n\"AppleSingle/AppleDouble Formats for Foreign Files\nDeveloper's Note\" [2]. The AppleDouble file itself is sent as\na multipart/appledouble message, which is only allowed to\nhave two parts. The header is sent as application/applefile\nand the data fork as whatever best describes it. For example\nshould a data part which is a GIF image be sent as image/gif.\nIf there is no content-type registered that is correct, the\ndata part should be sent as an application/octet-stream.\n\nAppleDouble is special case of AppleSingle. The Data fork of\nthe Macintosh file is extracted from the AppleSingle file and\nis stored separately. Therefore an implementation for\nAppleSingle can also decode AppleDouble files.\n\nThe first four bytes of an AppleDouble header is, in\nhexadecimal: 00, 05, 16, 07.\n\nThe AppleDouble header is binary data. Hence, it may be\nnecessary to perform a Content-Transfer-Encoding for\ntransmission. The safest encoding is Base64, since it permits\ntransfer over the most limited media. Even the Data fork of\nthe file might need transportation encoding for transmission.\n\nAn AppleDouble header file includes the original Macintosh\nfilename, so the filename used when storing the file on a\nforeign filesystem is of no importance. The only thing that\nmight be of some importance is the naming scheme used to keep\nthe AppleDouble header file together with the data part. The\nscheme used differs between different foreign file systems\nand the rules is presented in \"AppleSingle/AppleDouble\nFormats for Foreign Files Developer's Note\" [2]. An example\nis that if the data file is named 'budget', the AppleDouble\nheader file should be named '%budget' on a UNIX filesystem.\nTo give a hint to the receiver what file is sent, a parameter\ncalled name can be used. The value of this parameter must be\nin such character set so it's accepted according to the rules\nin RFC-1341 [1].\n\nThe AppleDouble header file also includes the original\nMacintosh file type, but to give a hint to the receiver what\ntype of file is sent, a parameter called type can be used.\nThe value of this parameter should be human readable, and in\nsuch character set so it's accepted according to the rules in\nRFC-1341 [1]. This parameter is of great importance for the\ndata part of the AppleDouble file to help non-Macintosh\ncomputers to extract the data. This scheme should be used on\nthe data part of the file only if there is no IANA registered\ncontent-type for MIME that matches the Macintosh type. For\nexample, the Macintosh type 'GIFf' can be sent as a MIME\ndocument with content type image/gif.\n\n\n\n5.4 AppleDouble example\n\n\n\n  Content-Type: multipart/appledouble; boundary=mac-part\n  \n  --mac-part\n  Content-Type: application/applefile; name=\"My-new-car\";\n  type=\"GIF picture\"\n  \n      [The AppleDouble header follows (starts with, in\n  hexadecimal: 00051607)]\n  \n  --mac-part\n  Content-Type: image/gif;\n  \n      [The Data fork (which in this case is a GIF image)\n  follows]\n  \n  --mac-part--\n\n\n6. Problems at the transition phase\n\n6.1 About the BinHex encoding\n\nA very widely spread way of sending Macintosh files with\nelectronic mail is to encode the Macintosh file with the\nBinHex4.0 encoding  (see appendix B for a brief description\nof the BinHex4.0 format).\n\nTo help the transition phase from sending BinHex4.0 files, to\nthis MacMIME specification where you send either AppleSingle\nor AppleDouble files encoded in some transport encoding\n(Base64 or Quoted-Printable), we also define an application\nsubtype named apple-binhex40.\n\nIt includes a CRC (Cyclic Redundancy Code) which can help\ndetecting transmission errors. To get a CRC on a message\nwhich use the AppleSingle or AppleDouble format, you have to\nuse it on the message itself. That kind of functionality is\nnot discussed in this memo.\n\nIt is the most widely spread encoding scheme for a Macintosh\nfile, which make it possible for almost all Macintosh users\nto decode a BinHex4.0 encoded file. The file can be saved as\na text file and decoded on a Macintosh. If a transportation\nencoding is done, the receiver must be MIME-aware to get the\nBinHex4.0 file. If not the receiver can receive the file and\ndecode it even if he is not MIME-aware.\n\nThe BinHex4.0 format should only be used as a replacement for\nthe AppleSingle format, i.e. it should only be used when\nsending files to Macintosh users, or when sending Macintosh\nspecific data (a Macintosh application for example).\n\n\n\n6.2 BinHex\n\nThe Content-Type application/mac-binhex40 describes that the\nbody of the mail is a BinHex4.0 file which follows the\ndescription in appendix B. Even though the BinHex encoding\nconsists of characters which are not the same as those used\nin Base64 (those regarded as safe according to RFC-1341) a\ntransportation encoding should not be done.\n\nThe one and only part of the file is sent in an\napplication/mac-binhex40 message.\n\nA BinHex4.0 file includes the original Macintosh filename, so\nthe filename used when storing the file on a foreign\nfilesystem is of no importance. But, to give a hint to the\nreceiver what file is sent, a parameter called name can be\nused. The value of this parameter must be in such character\nset so it's accepted according to the rules in RFC-1341 [1].\n\n\n\n6.3 BinHex example\n\n  Content-Type: application/mac-binhex40; name=\"car.hqx\"\n  \n      [The BinHex4.0 file which is NOT encoded follows]\n\n\n7. References\n\n\n\n   [1]Borenstein N., and N. Freed, MIME (Multipurpose\n      Internet Mail Extensions):  Mechanisms for Specifying\n      and Describing the Format of Internet Message Bodies,\n      RFC 1341, Bellcore, Innosoft, June 1992.\n      \n   \n   \n   [2]AppleSingle/AppleDouble Formats for Foreign Files\n      Developer's Note, Apple Computer, Inc., 1990\n      \n\n\n8. Security Considerations\n\nSecurity issues are not discussed in this memo.\n\n\n\n9. Acknowledgements\n\nThanks to all of the people on the ietf-822 list who have\ncome with great input for this document.\n\nSome of them must though be remembered by name, because they\nhave almost crushed my mailbox the last weeks with a very\nnice and interesting debate:\n\n    Dave Crocker\n    Steve Dorner\n    Erik E. Fair\n    David Gelhar\n    David Herron\n    Raymond Lau\n    John B. Melby\n    Rens Troost\n    Peter Svanberg\n    \n\n\n10. Author's Address\n\n    Patrik Faeltstroem\n    Department of Numerical Analysis and Computing Science\n    Royal Institute of Technology\n    S-100 44 Stockholm\n    Sweden\n    \n    Email: paf&nada.kth.se\n    \n11. Appendix A: AppleSingle and AppleDouble formats\n\n\n\n11.1 The AppleSingle format\n\nIn the AppleSingle format, a file's contents and attributes\nare stored in a single file in the foreign file system. For\nexample, both forks of a Macintosh file, the Finder\ninformation, and an associated comment are arranged in a\nsingle file with a simple structure.\n\nAn AppleSingle file consists of a header followed by one or\nmore data entries. The header consists of several fixed\nfields and a list of entry descriptors, each pointing to a\ndata entry. Each entry is optional and may or may not appear\nin the file.\n\n  AppleSingle file header:\n  \n     Field             Length\n\n     Magic number      4 bytes\n\n     Version number    4 bytes\n\n     Filler            16 bytes\n\n     Number of entries 2 bytes\n\n  \n  Entry descriptor for each entry:\n  \n     Entry ID          4 bytes\n\n     Offset            4 bytes\n\n     Length            4 bytes\n\n\n\nByte ordering in the file fields follows MC68000 conventions,\nmost significant byte first. The fields in the header file\nfollow the conventions described in the following sections.\n\n  Magic number\n  \nThis field, modelled after the UNIX magic number feature,\nspecifies the file's format. Apple has defined the magic\nnumber for the AppleSingle format as $00051600 or 0x00051600.\n\n  Version number\n  \nThis field denotes the version of AppleSingle format in the\nevent the format evolves (more fields may be added to the\nheader). The version described in this note is version\n$00020000 or 0x00020000.\n\n  Filler\n  \nThis field is all zeros ($00 or 0x00).\n\n  Number of entries\n  \nThis field specifies how many different entries are included\nin the file. It is an unsigned 16-bit number. If the number\nof entries is any number other than 0, then that number of\nentry descriptors immediately follows the number of entries\nfield.\n\n  Entry descriptors\n  \nThe entry descriptor is made up of the following three\nfields:\n\n   Entry ID    an unsigned 32-bit number, defines what entry\n           is. Entry IDs range from 1 to $FFFFFFFF. Entry ID\n           0 is invalid.\n           \n   Offset an unsigned 32-bit number, shows the offset from\n           the beginning of the file to the beginning of the\n           entry's data.\n           \n   Length an unsigned 32-bit number, shows the length of\n           the data in bytes. The length can be 0.\n           \n\n\n     Predefined entry ID's\n  \nApple has defined a set of entry IDs and their values as\nfollows:\n\n    Data Fork        1   Data fork\n\n    Resource Fork    2   Resource fork\n\n    Real Name        3   File's name as created on home file\nsystem\n\n    Comment          4   Standard Macintosh comment\n\n    Icon, B&W        5   Standard Macintosh black and white\nicon\n\n    Icon, Colour     6   Macintosh colour icon\n\n    File Dates Info  8   File creation date, modification\ndate, and so on\n\n    Finder Info      9   Standard Macintosh Finder\ninformation\n\n    Macintosh File Info  10  Macintosh file information,\nattributes and so on\n\n    ProDOS File Info11   ProDOS file information, attributes\nand so on\n\n    MS-DOS File Info12   MS-DOS file information, attributes\nand so on\n\n    Short Name      13   AFP short name\n\n    AFP File Info   14   AFP file, information, attributes\nand so on\n\n    Directory ID    15   AFP directory ID\n\n\n\nApple reserves the range of entry IDs from 1 to $7FFFFFFF.\nThe rest of the range is available for applications to define\ntheir own entries. Apple does not arbitrate the use of the\nrest of the range.\n\n\n\n11.2 The AppleDouble format\n\nThe AppleDouble format uses two files to store data,\nresources and attributes. The AppleDouble Data file contains\nthe data fork and the AppleDouble Header file contains the re\nsource fork.\n\nThe AppleDouble Data file contains the standard Macintosh\ndata fork with no additional header. The AppleDouble Header\nfile has exactly the same format as the AppleSingle file,\nexcept that it does not contain a Data fork entry. The magic\nnumber in the AppleDouble Header file differs from the magic\nnumber in the AppleSingle Header file so that an application\ncan tell whether it needs to look in another file for the\ndata fork. The magic number for the AppleDouble format is\n$00051607 or 0x00051607.\n\nThe entries in the AppleDouble Header file can appear in any\norder; however, since the resource fork is the entry that is\nmost commonly extended (after the data fork), Apple recom\nmends that the resource fork entry to be placed last in the\nfile. The data fork is easily extended because it resides by\nitself in the AppleDouble Data file.\n\n\n\n\n\n12. Appendix B: BinHex format\n\nHere is a description of the Hqx7 (7 bit format as\nimplemented in BinHex 4.0) formats for Macintosh Application\nand File transfers.\n\nThe main features of the format are:\n\n    1) Error checking even using ASCII download\n\n    2) Compression of repetitive characters\n\n    3) 7 bit encoding for ASCII download\n\nHQX Format Description (This is not intended to be a\nprogrammer's reference).\n\nThe format is processed at three different levels:\n\n  1) 8 bit encoding of the file:\n  \n    Byte: Length of FileName (1->63)\n\n    Bytes:    FileName (\"Length\" bytes)\n\n    Byte: Version\n\n    Long: Type\n\n    Long: Creator\n\n    Word: Flags (And $F800)\n\n    Long: Length of Data Fork\n\n    Long: Length of Resource Fork\n\n    Word: CRC\n\n    Bytes:    Data Fork (\"Data Length\" bytes)\n\n    Word: CRC\n\n    Bytes:    Resource Fork (\"Rsrc Length\" bytes)\n\n    Word: CRC\n\n  \n  \n  2) Compression of repetitive characters.\n  \n ($90 is the marker, encoding is made for 3->255 characters)\n\n00 11 22 33 44 55 66 77 ->  00 11 22 33 44 55 66 77\n\n11 22 22 22 22 22 22 33 ->  11 22 90 06 33\n\n11 22 90 33 44          ->  11 22 90 00 33 44\n\n  \n  \n  3) 7 bit encoding.\n  \nThe whole file is considered as a stream of bits. This stream\nwill be divided in blocks of 6 bits and then converted to one\nof 64 characters contained in a table. The characters in this\ntable have been chosen for maximum noise protection. The\nformat will start with a \":\" (first character on a line) and\nend with a \":\". There will be a maximum of 64 characters on a\nline. It must be preceded, by this comment, starting in\ncolumn 1 (it does not start in column 1 in this document):\n\n      (This file must be converted with BinHex 4.0)\n\n\nAny text before this comment is to be ignored.\n\nThe characters used is:\n\n  !\"#$%&'()*+,-\n  012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr\n\n\n"
  },
  "references": []
}