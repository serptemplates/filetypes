{
  "type": "application",
  "subtype": "pkcs8-encrypted",
  "full": "application/pkcs8-encrypted",
  "extensions": [],
  "sources": [
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    },
    {
      "source": "iana",
      "url": "https://www.iana.org/assignments/media-types/media-types.xhtml"
    },
    {
      "source": "apache",
      "url": "https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types"
    },
    {
      "source": "nginx",
      "url": "https://hg.nginx.org/nginx/raw-file/default/conf/mime.types"
    },
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    }
  ],
  "iana": {
    "template_url": "https://www.iana.org/assignments/media-types/application/pkcs8-encrypted",
    "type_name": "application",
    "subtype_name": "pkcs8-encrypted",
    "security_considerations": "Carries a cryptographic private key.  See Section 6 of [RFC5958].\n\n   EncryptedPrivateKeyInfo PKCS #8 data contains exactly one private\n   key.  Poor password choices, weak algorithms, or improper\n   parameter selections (e.g., insufficient salting rounds) will make\n   the confidential payloads much easier to compromise.",
    "interoperability_considerations": "PKCS #8 is a widely recognized format for private key information\n   on all modern cryptographic stacks.  The contents are exactly one\n   private key (with optional key attributes), so there is no\n   possibility for hidden \"Easter eggs\" in the payload such as\n   unexpected certificates or miscellaneous secrets.\n\n   The encrypted variation in this registration,\n   EncryptedPrivateKeyInfo (Section 3, \"Encrypted Private Key Info\",\n   of [RFC5958], and Section 6 of PKCS #8 as originally described in\n   [RFC5208], which was obsoleted by [RFC5958]), is less widely used\n   for exchange than PKCS #12, but it is much simpler to implement.\n   Actually, PKCS #12 incorporates the PKCS #8 types, so a PKCS #12\n   processor ought to be able to process PKCS #8 data by embedding\n   the PKCS #8 data in PKCS #12 \"scaffolding\".\n\n   The password-mapping parameter aids in interoperability when the\n   creator (who encrypted the keying material) and the user (who is\n   attempting to decrypt the keying material) are not operating in\n   the same character-encoding environment.  An anticipated scenario\n   is that the creator may have created the keying material with a\n   password in a Shift-JIS environment a long time ago, while the\n   user is in a UTF-8 environment.  There are potentially many\n   Unicode sequences that code for the same abstract character, such\n   as precomposed and decomposed forms; yet, such an abstract\n   character (however coded in Unicode) will tend to map to one\n   coding in the legacy charset, if it can be represented at all.\n   Therefore, the password-mapping parameter will almost never be\n   ambiguous when mapping to legacy encodings.  When mapping from one\n   Unicode form to another (such as an internal Unicode\n   representation to *pkcs12), code sequences are either preserved or\n   folded deterministically to common Unicode code points or\n   sequences, producing the same holistic result as mapping to legacy\n   encodings.\n\n   It is possible that an abstract character might map to multiple\n   legacy encodings under the same charset.  However, the possibility\n   is sufficiently remote as to be ignored in this media type\n   registration.  One possible workaround is to set the user's\n   (decrypting party's) local operating environment to the password-\n   mapping legacy encoding parameter for the purpose of generating\n   the password octet string from user input.  Another possibility is\n   to generate all possible legacy encoding combinations from the\n   abstract text (i.e., Unicode text), attempting decryption with\n   them.  Customized behavior can be defined by updating this media\n   type registration with a new password-mapping special value,\n   prefixed with *.",
    "applications": "Machines, applications, browsers, Internet kiosks, and so on, that\n   support this standard allow a user to import, export, and exercise\n   a single private key.\n\nFragment identifier considerations: None.",
    "additional_information": "Deprecated alias names for this type: N/A\n   Magic number(s): None.\n   File extension(s): .p8e\n   Macintosh file type code(s): None.  A uniform type identifier\n   (UTI) of \"com.rsa.pkcs-8-encrypted\" is recommended.\n\nObject Identifiers: 1.2.840.113549.1.12.10.1.2 (when in PKCS #12)",
    "intended_usage": "common",
    "template_text": "Type name: application\n\nSubtype name: pkcs8-encrypted\n\nRequired parameters: None.\n\nOptional parameters:\n\n   password-mapping:  The private key is encrypted with an encryption\n     algorithm, which could be a password-based encryption scheme as\n     that term is used in PKCS #5 ([RFC2898] and [RFC8018]).  Such\n     algorithms take a password as input.  A \"password\" is a secret\n     text value (see Section 3 of [RFC2898] and [RFC8018]), but for\n     algorithmic purposes the term \"password\" refers to an octet\n     string (see Section 2 of [RFC2898] and [RFC8018]).  Therefore,\n     there must be some mapping between the text value (which might\n     be user input) and the octet string.  Section 3 of [RFC2898]\n     (which was replaced by [RFC8018]) recommends \"that applications\n     follow some common text encoding rules\"; it then offers, but\n     does not recommend, ASCII and UTF-8.\n\n     While many modern applications support Unicode and Unicode-based\n     encodings such as UTF-8 and UTF-16, interchange is still needed\n     with private key artifacts that are encrypted with passwords in\n     other encodings.  Therefore, this parameter specifies the\n     charset (see Section 1.3 of [RFC2978]) that a recipient should\n     attempt first, in \"reverse\", when mapping from a sequence of\n     characters to an octet string.  This parameter is not\n     cryptographically protected, so recipients cannot rely on it as\n     the exclusive mapping possibility.\n\n     This parameter has similar semantics to the charset parameter\n     from text/plain, except that it only applies to the user's input\n     (text value) of a password.  There is no default value.\n\n     The following special values, which all begin with \"*\" to\n     distinguish them from registered charsets, are defined:\n\n     *pkcs12      UTF-16LE with U+0000 NULL terminator: PKCS #12\n                  style, see [RFC7292].\n\n     *precis      Preparation, Enforcement, and Comparison of\n                  Internationalized Strings (PRECIS) password\n                  profile, i.e., OpaqueString from Section 4 of\n                  [RFC7613], which was obsoleted by [RFC8265]: \n                  always UTF-8 in Normalization Form C (NFC).\n\n     *precis-XXX  Any profile from the IANA \"PRECIS Profiles\"\n                  registry where \"XXX\" is replaced by the profile\n                  name as shown in the registry.\n\n     *hex         hexadecimal input: the input is mapped to 0-9, A-F,\n                  and then converted directly to octets.  If there\n                  are an odd number of hex digits, either the final\n                  digit 0 is appended or an error condition is\n                  raised.  Compare with Annex M.4 of\n                  [IEEE.802.11-2012].\n\n     *dtmf        The characters \"0\"-\"9\", \"A\"-\"D\", \"*\", and \"#\",\n                  which map to their corresponding ASCII codes.\n                  \"A\"-\"D\" map to the uppercase range 0x41 - 0x44.\n                  (This is to support restricted-input devices, i.e.,\n                  telephones and telephone-like equipment.)  User\n                  input outside of these values is either ignored or\n                  an error condition is raised.\n\n     Otherwise, the value of this parameter is a charset, from the\n     IANA \"Character Sets\" registry \n     <http://www.iana.org/assignments/character-sets>.\n\n     This parameter is case insensitive.\n\nEncoding considerations: Binary.\n\nSecurity considerations:\n\n   Carries a cryptographic private key.  See Section 6 of [RFC5958].\n\n   EncryptedPrivateKeyInfo PKCS #8 data contains exactly one private\n   key.  Poor password choices, weak algorithms, or improper\n   parameter selections (e.g., insufficient salting rounds) will make\n   the confidential payloads much easier to compromise.\n\nInteroperability considerations:\n\n   PKCS #8 is a widely recognized format for private key information\n   on all modern cryptographic stacks.  The contents are exactly one\n   private key (with optional key attributes), so there is no\n   possibility for hidden \"Easter eggs\" in the payload such as\n   unexpected certificates or miscellaneous secrets.\n\n   The encrypted variation in this registration,\n   EncryptedPrivateKeyInfo (Section 3, \"Encrypted Private Key Info\",\n   of [RFC5958], and Section 6 of PKCS #8 as originally described in\n   [RFC5208], which was obsoleted by [RFC5958]), is less widely used\n   for exchange than PKCS #12, but it is much simpler to implement.\n   Actually, PKCS #12 incorporates the PKCS #8 types, so a PKCS #12\n   processor ought to be able to process PKCS #8 data by embedding\n   the PKCS #8 data in PKCS #12 \"scaffolding\".\n\n   The password-mapping parameter aids in interoperability when the\n   creator (who encrypted the keying material) and the user (who is\n   attempting to decrypt the keying material) are not operating in\n   the same character-encoding environment.  An anticipated scenario\n   is that the creator may have created the keying material with a\n   password in a Shift-JIS environment a long time ago, while the\n   user is in a UTF-8 environment.  There are potentially many\n   Unicode sequences that code for the same abstract character, such\n   as precomposed and decomposed forms; yet, such an abstract\n   character (however coded in Unicode) will tend to map to one\n   coding in the legacy charset, if it can be represented at all.\n   Therefore, the password-mapping parameter will almost never be\n   ambiguous when mapping to legacy encodings.  When mapping from one\n   Unicode form to another (such as an internal Unicode\n   representation to *pkcs12), code sequences are either preserved or\n   folded deterministically to common Unicode code points or\n   sequences, producing the same holistic result as mapping to legacy\n   encodings.\n\n   It is possible that an abstract character might map to multiple\n   legacy encodings under the same charset.  However, the possibility\n   is sufficiently remote as to be ignored in this media type\n   registration.  One possible workaround is to set the user's\n   (decrypting party's) local operating environment to the password-\n   mapping legacy encoding parameter for the purpose of generating\n   the password octet string from user input.  Another possibility is\n   to generate all possible legacy encoding combinations from the\n   abstract text (i.e., Unicode text), attempting decryption with\n   them.  Customized behavior can be defined by updating this media\n   type registration with a new password-mapping special value,\n   prefixed with *.\n\nPublished specification:\n\n   RSA Laboratories PKCS #8 v1.2 RSA Encryption Standard, November\n   1993 (republished as [RFC5208], May 2008, and updated as\n   [RFC5958], August 2010); RFC 5958, August 2010\n\nApplications that use this media type:\n\n   Machines, applications, browsers, Internet kiosks, and so on, that\n   support this standard allow a user to import, export, and exercise\n   a single private key.\n\nFragment identifier considerations: None.\n\nAdditional information:\n\n   Deprecated alias names for this type: N/A\n   Magic number(s): None.\n   File extension(s): .p8e\n   Macintosh file type code(s): None.  A uniform type identifier\n   (UTI) of \"com.rsa.pkcs-8-encrypted\" is recommended.\n\nObject Identifiers: 1.2.840.113549.1.12.10.1.2 (when in PKCS #12)\n\nPerson & email address to contact for further information:\n\n  Sean Leonard <dev+ietf&seantek.com>\n\nIntended usage: COMMON\n\nRestrictions on usage: None.\n\nAuthor/Change controller: Sean Leonard <dev+ietf&seantek.com>\n\nProvisional registration?  No"
  },
  "references": [
    {
      "title": "RFC 5208",
      "url": "https://www.rfc-editor.org/rfc/rfc5208.html",
      "kind": "RFC"
    },
    {
      "title": "RFC 5958",
      "url": "https://www.rfc-editor.org/rfc/rfc5958.html",
      "kind": "RFC"
    }
  ]
}