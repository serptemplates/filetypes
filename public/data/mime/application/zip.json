{
  "type": "application",
  "subtype": "zip",
  "full": "application/zip",
  "extensions": [
    "zip"
  ],
  "sources": [
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    },
    {
      "source": "iana",
      "url": "https://www.iana.org/assignments/media-types/media-types.xhtml"
    },
    {
      "source": "apache",
      "url": "https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types"
    },
    {
      "source": "nginx",
      "url": "https://hg.nginx.org/nginx/raw-file/default/conf/mime.types"
    },
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    }
  ],
  "iana": {
    "template_url": "https://www.iana.org/assignments/media-types/application/zip",
    "encoding_considerations": "ZIP files are binary data and thus should be encoded for MIME mail\ntransmission.  The same guidelines that apply to\napplication/octet-stream apply to this.\n\nThis filetype is not recommended for normal use, since Content-Type\ninformation for the files contained within the archive are not known.\nInstead multipart/mixed should be used and each file should have it's\nown Content-Type.\n\nNote that the algorithms used within the zip archive format may be\nunder certain patents.  Caveat Empor..",
    "security_considerations": "Extracting a zipfile could possible overwrite existing files.  Care\nshould be taken that files are extracted into an empty directory, not\nat the root level.",
    "template_text": "\n\nFrom lindner&mudhoney.micro.umn.edu Tue Jul 20 18:50:25 1993\nFrom: lindner&mudhoney.micro.umn.edu (Paul Lindner)\nSubject: Registration of a new MIME Content-Type/Subtype\nTo: iana&ISI.EDU, gopher&boombox.micro.umn.edu (Team Gopher)\nDate: Tue, 20 Jul 93 20:50:34 CDT\nReply-To: lindner&boombox.micro.umn.edu\nContent-Length: 37317\nStatus: RO\nX-Lines: 1049\n\nMIME TYPE NAME:\napplication\n\nMIME SUBTYPE NAME:\nzip\n\nREQUIRED PARAMETERS:\nnone\n\nOPTIONAL PARAMETERS:\nnone\n\nENCODING CONSIDERATIONS:\n\nZIP files are binary data and thus should be encoded for MIME mail\ntransmission.  The same guidelines that apply to\napplication/octet-stream apply to this.\n\nThis filetype is not recommended for normal use, since Content-Type\ninformation for the files contained within the archive are not known.\nInstead multipart/mixed should be used and each file should have it's\nown Content-Type.\n\nNote that the algorithms used within the zip archive format may be\nunder certain patents.  Caveat Empor..\n\nSECURITY CONSIDERATIONS:\nExtracting a zipfile could possible overwrite existing files.  Care\nshould be taken that files are extracted into an empty directory, not\nat the root level.\n\nPUBLISHED SPECIFICATION:\n\nPKWARE Inc. controls the specification.  What follows is the most\ncurrent specification for a ZIP file.\n\n\nDisclaimer\n----------\n\nAlthough PKWARE will attempt to supply current and accurate\ninformation relating to its file formats, algorithms, and the\nsubject programs, the possibility of error can not be eliminated.\nPKWARE therefore expressly disclaims any warranty that the\ninformation contained in the associated materials relating to the\nsubject programs and/or the format of the files created or\naccessed by the subject programs and/or the algorithms used by\nthe subject programs, or any other matter, is current, correct or\naccurate as delivered.  Any risk of damage due to any possible\ninaccurate information is assumed by the user of the information.\nFurthermore, the information relating to the subject programs\nand/or the file formats created or accessed by the subject\nprograms and/or the algorithms used by the subject programs is\nsubject to change without notice.\n\n\nGeneral Format of a ZIP file\n----------------------------\n\n  Files stored in arbitrary order.  Large zipfiles can span multiple\n  diskette media.\n\n  Overall zipfile format:\n\n    [local file header + file data + data_descriptor] . . .\n    [central directory] end of central directory record\n\n\n  A.  Local file header:\n\n\tlocal file header signature     4 bytes  (0x04034b50)\n\tversion needed to extract       2 bytes\n\tgeneral purpose bit flag        2 bytes\n\tcompression method              2 bytes\n\tlast mod file time              2 bytes\n\tlast mod file date              2 bytes\n\tcrc-32                          4 bytes\n\tcompressed size                 4 bytes\n\tuncompressed size               4 bytes\n\tfilename length                 2 bytes\n\textra field length              2 bytes\n\n\tfilename (variable size)\n\textra field (variable size)\n\n\n  B.  Data descriptor:\n\n\tcrc-32                          4 bytes\n\tcompressed size                 4 bytes\n\tuncompressed size               4 bytes\n\n      This descriptor exists only if bit 3 of the general\n      purpose bit flag is set (see below).  It is byte aligned\n      and immediately follows the last byte of compressed data.\n      This descriptor is used only when it was not possible to\n      seek in the output zip file, e.g., when the output zip file\n      was standard output or a non seekable device.\n\n  C.  Central directory structure:\n\n      [file header] . . .  end of central dir record\n\n      File header:\n\n\tcentral file header signature   4 bytes  (0x02014b50)\n\tversion made by                 2 bytes\n\tversion needed to extract       2 bytes\n\tgeneral purpose bit flag        2 bytes\n\tcompression method              2 bytes\n\tlast mod file time              2 bytes\n\tlast mod file date              2 bytes\n\tcrc-32                          4 bytes\n\tcompressed size                 4 bytes\n\tuncompressed size               4 bytes\n\tfilename length                 2 bytes\n\textra field length              2 bytes\n\tfile comment length             2 bytes\n\tdisk number start               2 bytes\n\tinternal file attributes        2 bytes\n\texternal file attributes        4 bytes\n\trelative offset of local header 4 bytes\n\n\tfilename (variable size)\n\textra field (variable size)\n\tfile comment (variable size)\n\n      End of central dir record:\n\n\tend of central dir signature    4 bytes  (0x06054b50)\n\tnumber of this disk             2 bytes\n\tnumber of the disk with the\n\tstart of the central directory  2 bytes\n\ttotal number of entries in\n\tthe central dir on this disk    2 bytes\n\ttotal number of entries in\n\tthe central dir                 2 bytes\n\tsize of the central directory   4 bytes\n\toffset of start of central\n\tdirectory with respect to\n\tthe starting disk number        4 bytes\n\tzipfile comment length          2 bytes\n\tzipfile comment (variable size)\n\n\n  D.  Explanation of fields:\n\n      version made by (2 bytes)\n\n\t  The upper byte indicates the host system (OS) for the\n\t  file.  Software can use this information to determine\n\t  the line record format for text files etc.  The current\n\t  mappings are:\n\n\t  0 - MS-DOS and OS/2 (F.A.T. file systems)\n\t  1 - Amiga                     2 - VAX/VMS\n\t  3 - *nix                      4 - VM/CMS\n\t  5 - Atari ST                  6 - OS/2 H.P.F.S.\n\t  7 - Macintosh                 8 - Z-System\n\t  9 - CP/M                      10 thru 255 - unused\n\n\t  The lower byte indicates the version number of the\n\t  software used to encode the file.  The value/10\n\t  indicates the major version number, and the value\n\t  mod 10 is the minor version number.\n\n      version needed to extract (2 bytes)\n\n\t  The minimum software version needed to extract the\n\t  file, mapped as above.\n\n      general purpose bit flag: (2 bytes)\n\n\t  bit 0: If set, indicates that the file is encrypted.\n\n\t  (For Method 6 - Imploding)\n\t  bit 1: If the compression method used was type 6,\n\t\t Imploding, then this bit, if set, indicates\n\t\t an 8K sliding dictionary was used.  If clear,\n\t\t then a 4K sliding dictionary was used.\n\t  bit 2: If the compression method used was type 6,\n\t\t Imploding, then this bit, if set, indicates\n\t\t an 3 Shannon-Fano trees were used to encode the\n\t\t sliding dictionary output.  If clear, then 2\n\t\t Shannon-Fano trees were used.\n\n\t  (For Method 8 - Deflating)\n\t  bit 2  bit 1\n\t    0      0    Normal (-en) compression option was used.\n\t    0      1    Maximum (-ex) compression option was used.\n\t    1      0    Fast (-ef) compression option was used.\n\t    1      1    Super Fast (-es) compression option was used.\n\n\t  Note:  Bits 1 and 2 are undefined if the compression\n\t\t method is any other.\n\n\t  (For method 8)\n\t  bit 3: If this bit is set, the fields crc-32, compressed size\n\t\t and uncompressed size are set to zero in the local\n\t\t header.  The correct values are put in the data descriptor\n\t\t immediately following the compressed data.\n\n\t  The upper three bits are reserved and used internally\n\t  by the software when processing the zipfile.  The\n\t  remaining bits are unused.\n\n      compression method: (2 bytes)\n\n\t  (see accompanying documentation for algorithm\n\t  descriptions)\n\n\t  0 - The file is stored (no compression)\n\t  1 - The file is Shrunk\n\t  2 - The file is Reduced with compression factor 1\n\t  3 - The file is Reduced with compression factor 2\n\t  4 - The file is Reduced with compression factor 3\n\t  5 - The file is Reduced with compression factor 4\n\t  6 - The file is Imploded\n\t  7 - Reserved for Tokenizing compression algorithm\n\t  8 - The file is Deflated\n\n      date and time fields: (2 bytes each)\n\n\t  The date and time are encoded in standard MS-DOS format.\n\t  If input came from standard input, the date and time are\n\t  those at which compression was started for this data.\n\n      CRC-32: (4 bytes)\n\n\t  The CRC-32 algorithm was generously contributed by\n\t  David Schwaderer and can be found in his excellent\n\t  book \"C Programmers Guide to NetBIOS\" published by\n\t  Howard W. Sams & Co. Inc.  The 'magic number' for\n\t  the CRC is 0xdebb20e3.  The proper CRC pre and post\n\t  conditioning is used, meaning that the CRC register\n\t  is pre-conditioned with all ones (a starting value\n\t  of 0xffffffff) and the value is post-conditioned by\n\t  taking the one's complement of the CRC residual.\n\t  If bit 3 of the general purpose flag is set, this\n\t  field is set to zero in the local header and the correct\n\t  value is put in the data descriptor and in the central\n\t  directory.\n\n      compressed size: (4 bytes)\n      uncompressed size: (4 bytes)\n\n\t  The size of the file compressed and uncompressed,\n\t  respectively.  If bit 3 of the general purpose bit flag\n\t  is set, these fields are set to zero in the local header\n\t  and the correct values are put in the data descriptor and\n\t  in the central directory.\n\n      filename length: (2 bytes)\n      extra field length: (2 bytes)\n      file comment length: (2 bytes)\n\n\t  The length of the filename, extra field, and comment\n\t  fields respectively.  The combined length of any\n\t  directory record and these three fields should not\n\t  generally exceed 65,535 bytes.  If input came from standard\n\t  input, the filename length is set to zero.\n\n\n      disk number start: (2 bytes)\n\n\t  The number of the disk on which this file begins.\n\n      internal file attributes: (2 bytes)\n\n\t  The lowest bit of this field indicates, if set, that\n\t  the file is apparently an ASCII or text file.  If not\n\t  set, that the file apparently contains binary data.\n\t  The remaining bits are unused in version 1.0.\n\n      external file attributes: (4 bytes)\n\n\t  The mapping of the external attributes is\n\t  host-system dependent (see 'version made by').  For\n\t  MS-DOS, the low order byte is the MS-DOS directory\n\t  attribute byte.  If input came from standard input, this\n\t  field is set to zero.\n\n      relative offset of local header: (4 bytes)\n\n\t  This is the offset from the start of the first disk on\n\t  which this file appears, to where the local header should\n\t  be found.\n\n      filename: (Variable)\n\n\t  The name of the file, with optional relative path.\n\t  The path stored should not contain a drive or\n\t  device letter, or a leading slash.  All slashes\n\t  should be forward slashes '/' as opposed to\n\t  backwards slashes '\\' for compatibility with Amiga\n\t  and Unix file systems etc.  If input came from standard\n\t  input, there is no filename field.\n\n      extra field: (Variable)\n\n\t  This is for future expansion.  If additional information\n\t  needs to be stored in the future, it should be stored\n\t  here.  Earlier versions of the software can then safely\n\t  skip this file, and find the next file or header.  This\n\t  field will be 0 length in version 1.0.\n\n\t  In order to allow different programs and different types\n\t  of information to be stored in the 'extra' field in .ZIP\n\t  files, the following structure should be used for all\n\t  programs storing data in this field:\n\n\t  header1+data1 + header2+data2 . . .\n\n\t  Each header should consist of:\n\n\t    Header ID - 2 bytes\n\t    Data Size - 2 bytes\n\n\t  Note: all fields stored in Intel low-byte/high-byte order.\n\n\t  The Header ID field indicates the type of data that is in\n\t  the following data block.\n\n\t  Header ID's of 0 thru 31 are reserved for use by PKWARE.\n\t  The remaining ID's can be used by third party vendors for\n\t  proprietary usage.\n\n\t  The current Header ID mappings are:\n\n\t  0x0007        AV Info\n\t  0x0009        OS/2\n\t  0x000c        VAX/VMS\n\n\t  The Data Size field indicates the size of the following\n\t  data block. Programs can use this value to skip to the\n\t  next header block, passing over any data blocks that are\n\t  not of interest.\n\n\t  Note: As stated above, the size of the entire .ZIP file\n\t\theader, including the filename, comment, and extra\n\t\tfield should not exceed 64K in size.\n\n\t  In case two different programs should appropriate the same\n\t  Header ID value, it is strongly recommended that each\n\t  program place a unique signature of at least two bytes in\n\t  size (and preferably 4 bytes or bigger) at the start of\n\t  each data area.  Every program should verify that its\n\t  unique signature is present, in addition to the Header ID\n\t  value being correct, before assuming that it is a block of\n\t  known type.\n\n\t -VAX/VMS Extra Field:\n\n\t  The following is the layout of the VAX/VMS attributes \"extra\"\n\t  block.  (Last Revision 12/17/91)\n\n\t  Note: all fields stored in Intel low-byte/high-byte order.\n\n\t  Value         Size            Description\n\t  -----         ----            -----------\n  (VMS)   0x000c        Short           Tag for this \"extra\" block type\n\t  TSize         Short           Size of the total \"extra\" block\n\t  CRC           Long            32-bit CRC for remainder of the block\n\t  Tag1          Short           VMS attribute tag value #1\n\t  Size1         Short           Size of attribute #1, in bytes\n\t  (var.)        Size1           Attribute #1 data\n\t  .\n\t  .\n\t  .\n\t  TagN          Short           VMS attribute tage value #N\n\t  SizeN         Short           Size of attribute #N, in bytes\n\t  (var.)        SizeN           Attribute #N data\n\n\t  Rules:\n\n\t  1. There will be one or more of attributes present, which will\n\t     each be preceded by the above TagX & SizeX values.  These\n\t     values are identical to the ATR$C_XXXX and ATR$S_XXXX constants\n\t     which are defined in ATR.H under VMS C.  Neither of these values\n\t     will ever be zero.\n\n\t  2. No word alignment or padding is performed.\n\n\t  3. A well-behaved PKZIP/VMS program should never produce more than\n\t     one sub-block with the same TagX value.  Also, there will never\n\t     be more than one \"extra\" block of type 0x000c in a particular\n\t     directory record.\n\n      file comment: (Variable)\n\n\t  The comment for this file.\n\n      number of this disk: (2 bytes)\n\n\t  The number of this disk, which contains central\n\t  directory end record.\n\n      number of the disk with the start of the central directory: (2 bytes)\n\n\t  The number of the disk on which the central\n\t  directory starts.\n\n      total number of entries in the central dir on this disk: (2 bytes)\n\n\t  The number of central directory entries on this disk.\n\n      total number of entries in the central dir: (2 bytes)\n\n\t  The total number of files in the zipfile.\n\n\n      size of the central directory: (4 bytes)\n\n\t  The size (in bytes) of the entire central directory.\n\n      offset of start of central directory with respect to\n      the starting disk number:  (4 bytes)\n\n\t  Offset of the start of the central direcory on the\n\t  disk on which the central directory starts.\n\n      zipfile comment length: (2 bytes)\n\n\t  The length of the comment for this zipfile.\n\n      zipfile comment: (Variable)\n\n\t  The comment for this zipfile.\n\n\n  D.  General notes:\n\n      1)  All fields unless otherwise noted are unsigned and stored\n\t  in Intel low-byte:high-byte, low-word:high-word order.\n\n      2)  String fields are not null terminated, since the\n\t  length is given explicitly.\n\n      3)  Local headers should not span disk boundries.  Also, even\n\t  though the central directory can span disk boundries, no\n\t  single record in the central directory should be split\n\t  across disks.\n\n      4)  The entries in the central directory may not necessarily\n\t  be in the same order that files appear in the zipfile.\n\nUnShrinking - Method 1\n----------------------\n\nShrinking is a Dynamic Ziv-Lempel-Welch compression algorithm\nwith partial clearing.  The initial code size is 9 bits, and\nthe maximum code size is 13 bits.  Shrinking differs from\nconventional Dynamic Ziv-Lempel-Welch implementations in several\nrespects:\n\n1)  The code size is controlled by the compressor, and is not\n    automatically increased when codes larger than the current\n    code size are created (but not necessarily used).  When\n    the decompressor encounters the code sequence 256\n    (decimal) followed by 1, it should increase the code size\n    read from the input stream to the next bit size.  No\n    blocking of the codes is performed, so the next code at\n    the increased size should be read from the input stream\n    immediately after where the previous code at the smaller\n    bit size was read.  Again, the decompressor should not\n    increase the code size used until the sequence 256,1 is\n    encountered.\n\n2)  When the table becomes full, total clearing is not\n    performed.  Rather, when the compresser emits the code\n    sequence 256,2 (decimal), the decompressor should clear\n    all leaf nodes from the Ziv-Lempel tree, and continue to\n    use the current code size.  The nodes that are cleared\n    from the Ziv-Lempel tree are then re-used, with the lowest\n    code value re-used first, and the highest code value\n    re-used last.  The compressor can emit the sequence 256,2\n    at any time.\n\n\n\nExpanding - Methods 2-5\n-----------------------\n\nThe Reducing algorithm is actually a combination of two\ndistinct algorithms.  The first algorithm compresses repeated\nbyte sequences, and the second algorithm takes the compressed\nstream from the first algorithm and applies a probabilistic\ncompression method.\n\nThe probabilistic compression stores an array of 'follower\nsets' S(j), for j=0 to 255, corresponding to each possible\nASCII character.  Each set contains between 0 and 32\ncharacters, to be denoted as S(j)[0],...,S(j)[m], where m<32.\nThe sets are stored at the beginning of the data area for a\nReduced file, in reverse order, with S(255) first, and S(0)\nlast.\n\nThe sets are encoded as { N(j), S(j)[0],...,S(j)[N(j)-1] },\nwhere N(j) is the size of set S(j).  N(j) can be 0, in which\ncase the follower set for S(j) is empty.  Each N(j) value is\nencoded in 6 bits, followed by N(j) eight bit character values\ncorresponding to S(j)[0] to S(j)[N(j)-1] respectively.  If\nN(j) is 0, then no values for S(j) are stored, and the value\nfor N(j-1) immediately follows.\n\nImmediately after the follower sets, is the compressed data\nstream.  The compressed data stream can be interpreted for the\nprobabilistic decompression as follows:\n\n\nlet Last-Character <- 0.\nloop until done\n    if the follower set S(Last-Character) is empty then\n\tread 8 bits from the input stream, and copy this\n\tvalue to the output stream.\n    otherwise if the follower set S(Last-Character) is non-empty then\n\tread 1 bit from the input stream.\n\tif this bit is not zero then\n\t    read 8 bits from the input stream, and copy this\n\t    value to the output stream.\n\totherwise if this bit is zero then\n\t    read B(N(Last-Character)) bits from the input\n\t    stream, and assign this value to I.\n\t    Copy the value of S(Last-Character)[I] to the\n\t    output stream.\n\n    assign the last value placed on the output stream to\n    Last-Character.\nend loop\n\n\nB(N(j)) is defined as the minimal number of bits required to\nencode the value N(j)-1.\n\n\nThe decompressed stream from above can then be expanded to\nre-create the original file as follows:\n\n\nlet State <- 0.\n\nloop until done\n    read 8 bits from the input stream into C.\n    case State of\n\t0:  if C is not equal to DLE (144 decimal) then\n\t\tcopy C to the output stream.\n\t    otherwise if C is equal to DLE then\n\t\tlet State <- 1.\n\n\t1:  if C is non-zero then\n\t\tlet V <- C.\n\t\tlet Len <- L(V)\n\t\tlet State <- F(Len).\n\t    otherwise if C is zero then\n\t\tcopy the value 144 (decimal) to the output stream.\n\t\tlet State <- 0\n\n\t2:  let Len <- Len + C\n\t    let State <- 3.\n\n\t3:  move backwards D(V,C) bytes in the output stream\n\t    (if this position is before the start of the output\n\t    stream, then assume that all the data before the\n\t    start of the output stream is filled with zeros).\n\t    copy Len+3 bytes from this position to the output stream.\n\t    let State <- 0.\n    end case\nend loop\n\n\nThe functions F,L, and D are dependent on the 'compression\nfactor', 1 through 4, and are defined as follows:\n\nFor compression factor 1:\n    L(X) equals the lower 7 bits of X.\n    F(X) equals 2 if X equals 127 otherwise F(X) equals 3.\n    D(X,Y) equals the (upper 1 bit of X) * 256 + Y + 1.\nFor compression factor 2:\n    L(X) equals the lower 6 bits of X.\n    F(X) equals 2 if X equals 63 otherwise F(X) equals 3.\n    D(X,Y) equals the (upper 2 bits of X) * 256 + Y + 1.\nFor compression factor 3:\n    L(X) equals the lower 5 bits of X.\n    F(X) equals 2 if X equals 31 otherwise F(X) equals 3.\n    D(X,Y) equals the (upper 3 bits of X) * 256 + Y + 1.\nFor compression factor 4:\n    L(X) equals the lower 4 bits of X.\n    F(X) equals 2 if X equals 15 otherwise F(X) equals 3.\n    D(X,Y) equals the (upper 4 bits of X) * 256 + Y + 1.\n\n\nImploding - Method 6\n--------------------\n\nThe Imploding algorithm is actually a combination of two distinct\nalgorithms.  The first algorithm compresses repeated byte\nsequences using a sliding dictionary.  The second algorithm is\nused to compress the encoding of the sliding dictionary ouput,\nusing multiple Shannon-Fano trees.\n\nThe Imploding algorithm can use a 4K or 8K sliding dictionary\nsize. The dictionary size used can be determined by bit 1 in the\ngeneral purpose flag word; a 0 bit indicates a 4K dictionary\nwhile a 1 bit indicates an 8K dictionary.\n\nThe Shannon-Fano trees are stored at the start of the compressed\nfile. The number of trees stored is defined by bit 2 in the\ngeneral purpose flag word; a 0 bit indicates two trees stored, a\n1 bit indicates three trees are stored.  If 3 trees are stored,\nthe first Shannon-Fano tree represents the encoding of the\nLiteral characters, the second tree represents the encoding of\nthe Length information, the third represents the encoding of the\nDistance information.  When 2 Shannon-Fano trees are stored, the\nLength tree is stored first, followed by the Distance tree.\n\nThe Literal Shannon-Fano tree, if present is used to represent\nthe entire ASCII character set, and contains 256 values.  This\ntree is used to compress any data not compressed by the sliding\ndictionary algorithm.  When this tree is present, the Minimum\nMatch Length for the sliding dictionary is 3.  If this tree is\nnot present, the Minimum Match Length is 2.\n\nThe Length Shannon-Fano tree is used to compress the Length part\nof the (length,distance) pairs from the sliding dictionary\noutput.  The Length tree contains 64 values, ranging from the\nMinimum Match Length, to 63 plus the Minimum Match Length.\n\nThe Distance Shannon-Fano tree is used to compress the Distance\npart of the (length,distance) pairs from the sliding dictionary\noutput. The Distance tree contains 64 values, ranging from 0 to\n63, representing the upper 6 bits of the distance value.  The\ndistance values themselves will be between 0 and the sliding\ndictionary size, either 4K or 8K.\n\nThe Shannon-Fano trees themselves are stored in a compressed\nformat. The first byte of the tree data represents the number of\nbytes of data representing the (compressed) Shannon-Fano tree\nminus 1.  The remaining bytes represent the Shannon-Fano tree\ndata encoded as:\n\n    High 4 bits: Number of values at this bit length + 1. (1 - 16)\n    Low  4 bits: Bit Length needed to represent value + 1. (1 - 16)\n\nThe Shannon-Fano codes can be constructed from the bit lengths\nusing the following algorithm:\n\n1)  Sort the Bit Lengths in ascending order, while retaining the\n    order of the original lengths stored in the file.\n\n2)  Generate the Shannon-Fano trees:\n\n    Code <- 0\n    CodeIncrement <- 0\n    LastBitLength <- 0\n    i <- number of Shannon-Fano codes - 1   (either 255 or 63)\n\n    loop while i >= 0\n\tCode = Code + CodeIncrement\n\tif BitLength(i) <> LastBitLength then\n\t    LastBitLength=BitLength(i)\n\t    CodeIncrement = 1 shifted left (16 - LastBitLength)\n\tShannonCode(i) = Code\n\ti <- i - 1\n    end loop\n\n\n3)  Reverse the order of all the bits in the above ShannonCode()\n    vector, so that the most significant bit becomes the least\n    significant bit.  For example, the value 0x1234 (hex) would\n    become 0x2C48 (hex).\n\n4)  Restore the order of Shannon-Fano codes as originally stored\n    within the file.\n\nExample:\n\n    This example will show the encoding of a Shannon-Fano tree\n    of size 8.  Notice that the actual Shannon-Fano trees used\n    for Imploding are either 64 or 256 entries in size.\n\nExample:   0x02, 0x42, 0x01, 0x13\n\n    The first byte indicates 3 values in this table.  Decoding the\n    bytes:\n\t    0x42 = 5 codes of 3 bits long\n\t    0x01 = 1 code  of 2 bits long\n\t    0x13 = 2 codes of 4 bits long\n\n    This would generate the original bit length array of:\n    (3, 3, 3, 3, 3, 2, 4, 4)\n\n    There are 8 codes in this table for the values 0 thru 7.  Using the\n    algorithm to obtain the Shannon-Fano codes produces:\n\n\t\t\t\t  Reversed     Order     Original\nVal  Sorted   Constructed Code      Value     Restored    Length\n---  ------   -----------------   --------    --------    ------\n0:     2      1100000000000000        11       101          3\n1:     3      1010000000000000       101       001          3\n2:     3      1000000000000000       001       110          3\n3:     3      0110000000000000       110       010          3\n4:     3      0100000000000000       010       100          3\n5:     3      0010000000000000       100        11          2\n6:     4      0001000000000000      1000      1000          4\n7:     4      0000000000000000      0000      0000          4\n\n\nThe values in the Val, Order Restored and Original Length columns\nnow represent the Shannon-Fano encoding tree that can be used for\ndecoding the Shannon-Fano encoded data.  How to parse the\nvariable length Shannon-Fano values from the data stream is beyond the\nscope of this document.  (See the references listed at the end of\nthis document for more information.)  However, traditional decoding\nschemes used for Huffman variable length decoding, such as the\nGreenlaw algorithm, can be succesfully applied.\n\nThe compressed data stream begins immediately after the\ncompressed Shannon-Fano data.  The compressed data stream can be\ninterpreted as follows:\n\nloop until done\n    read 1 bit from input stream.\n\n    if this bit is non-zero then       (encoded data is literal data)\n\tif Literal Shannon-Fano tree is present\n\t    read and decode character using Literal Shannon-Fano tree.\n\totherwise\n\t    read 8 bits from input stream.\n\tcopy character to the output stream.\n    otherwise                   (encoded data is sliding dictionary match)\n\tif 8K dictionary size\n\t    read 7 bits for offset Distance (lower 7 bits of offset).\n\totherwise\n\t    read 6 bits for offset Distance (lower 6 bits of offset).\n\n\tusing the Distance Shannon-Fano tree, read and decode the\n\t  upper 6 bits of the Distance value.\n\n\tusing the Length Shannon-Fano tree, read and decode\n\t  the Length value.\n\n\tLength <- Length + Minimum Match Length\n\n\tif Length = 63 + Minimum Match Length\n\t    read 8 bits from the input stream,\n\t    add this value to Length.\n\n\tmove backwards Distance+1 bytes in the output stream, and\n\tcopy Length characters from this position to the output\n\tstream.  (if this position is before the start of the output\n\tstream, then assume that all the data before the start of\n\tthe output stream is filled with zeros).\nend loop\n\nTokenizing - Method 7\n--------------------\n\nThis method is not used by PKZIP.\n\nDeflating - Method 8\n-----------------\n\nThe Deflate algorithm is similar to the Implode algorithm using\na sliding dictionary of up to 32K with secondary compression\nfrom Huffman/Shannon-Fano codes.\n\nThe compressed data is stored in blocks with a header describing\nthe block and the Huffman codes used in the data block.  The header\nformat is as follows:\n\n   Bit 0: Last Block bit     This bit is set to 1 if this is the last\n\t\t\t     compressed block in the data.\n   Bits 1-2: Block type\n      00 (0) - Block is stored - All stored data is byte aligned.\n\t       Skip bits until next byte, then next word = block length,\n\t       followed by the ones compliment of the block length word.\n\t       Remaining data in block is the stored data.\n\n      01 (1) - Use fixed Huffman codes for literal and distance codes.\n\t       Lit Code    Bits             Dist Code   Bits\n\t       ---------   ----             ---------   ----\n\t\t 0 - 143    8                 0 - 31      5\n\t       144 - 255    9\n\t       256 - 279    7\n\t       280 - 287    8\n\n\t       Literal codes 286-287 and distance codes 30-31 are never\n\t       used but participate in the huffman construction.\n\n      10 (2) - Dynamic Huffman codes.  (See expanding Huffman codes)\n\n      11 (3) - Reserved - Flag a \"Error in compressed data\" if seen.\n\nExpanding Huffman Codes\n-----------------------\nIf the data block is stored with dynamic Huffman codes, the Huffman\ncodes are sent in the following compressed format:\n\n   5 Bits: # of Literal codes sent - 256 (256 - 286)\n\t   All other codes are never sent.\n   5 Bits: # of Dist codes - 1           (1 - 32)\n   4 Bits: # of Bit Length codes - 3     (3 - 19)\n\nThe Huffman codes are sent as bit lengths and the codes are built as\ndescribed in the implode algorithm.  The bit lengths themselves are\ncompressed with Huffman codes.  There are 19 bit length codes:\n\n   0 - 15: Represent bit lengths of 0 - 15\n       16: Copy the previous bit length 3 - 6 times.\n\t   The next 2 bits indicate repeat length (0 = 3, ... ,3 = 6)\n\t      Example:  Codes 8, 16 (+2 bits 11), 16 (+2 bits 10) will\n\t\t\texpand to 12 bit lengths of 8 (1 + 6 + 5)\n       17: Repeat a bit length of 0 for 3 - 10 times. (3 bits of length)\n       18: Repeat a bit length of 0 for 11 - 138 times (7 bits of length)\n\nThe lengths of the bit length codes are sent packed 3 bits per value\n(0 - 7) in the following order:\n\n   16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15\n\nThe Huffman codes should be built as described in the Implode algorithm\nexcept codes are assigned starting at the shortest bit length, i.e. the\nshortest code should be all 0's rather than all 1's.  Also, codes with\na bit length of zero do not participate in the tree construction.  The\ncodes are then used to decode the bit lengths for the literal and distance\ntables.\n\nThe bit lengths for the literal tables are sent first with the number\nof entries sent described by the 5 bits sent earlier.  There are up\nto 286 literal characters; the first 256 represent the respective 8\nbit character, code 256 represents the End-Of-Block code, the remaining\n29 codes represent copy lengths of 3 thru 258.  There are up to 30\ndistance codes representing distances from 1 thru 32k as described\nbelow.\n\n\t\t\t     Length Codes\n\t\t\t     ------------\n      Extra             Extra              Extra              Extra\n Code Bits Length  Code Bits Lengths  Code Bits Lengths  Code Bits Length(s)\n ---- ---- ------  ---- ---- -------  ---- ---- -------  ---- ---- ---------\n  257   0     3     265   1   11,12    273   3   35-42    281   5  131-162\n  258   0     4     266   1   13,14    274   3   43-50    282   5  163-194\n  259   0     5     267   1   15,16    275   3   51-58    283   5  195-226\n  260   0     6     268   1   17,18    276   3   59-66    284   5  227-257\n  261   0     7     269   2   19-22    277   4   67-82    285   0    258\n  262   0     8     270   2   23-26    278   4   83-98\n  263   0     9     271   2   27-30    279   4   99-114\n  264   0    10     272   2   31-34    280   4  115-130\n\n\t\t\t    Distance Codes\n\t\t\t    --------------\n      Extra           Extra             Extra               Extra\n Code Bits Dist  Code Bits  Dist   Code Bits Distance  Code Bits Distance\n ---- ---- ----  ---- ---- ------  ---- ---- --------  ---- ---- --------\n   0   0    1      8   3   17-24    16    7  257-384    24   11  4097-6144\n   1   0    2      9   3   25-32    17    7  385-512    25   11  6145-8192\n   2   0    3     10   4   33-48    18    8  513-768    26   12  8193-12288\n   3   0    4     11   4   49-64    19    8  769-1024   27   12 12289-16384\n   4   1   5,6    12   5   65-96    20    9 1025-1536   28   13 16385-24576\n   5   1   7,8    13   5   97-128   21    9 1537-2048   29   13 24577-32768\n   6   2   9-12   14   6  129-192   22   10 2049-3072\n   7   2  13-16   15   6  193-256   23   10 3073-4096\n\nThe compressed data stream begins immediately after the\ncompressed header data.  The compressed data stream can be\ninterpreted as follows:\n\ndo\n   read header from input stream.\n\n   if stored block\n      skip bits until byte aligned\n      read count and 1's compliment of count\n      copy count bytes data block\n   otherwise\n      loop until end of block code sent\n\t decode literal character from input stream\n\t if literal < 256\n\t    copy character to the output stream\n\t otherwise\n\t    if literal = end of block\n\t       break from loop\n\t    otherwise\n\t       decode distance from input stream\n\n\t       move backwards distance bytes in the output stream, and\n\t       copy length characters from this position to the output\n\t       stream.\n      end loop\nwhile not last block\n\nif data descriptor exists\n   skip bits until byte aligned\n   read crc and sizes\nendif\n\nDecryption\n----------\n\nThe encryption used in PKZIP was generously supplied by Roger\nSchlafly.  PKWARE is grateful to Mr. Schlafly for his expert\nhelp and advice in the field of data encryption.\n\nPKZIP encrypts the compressed data stream.  Encrypted files must\nbe decrypted before they can be extracted.\n\nEach encrypted file has an extra 12 bytes stored at the start of\nthe data area defining the encryption header for that file.  The\nencryption header is originally set to random values, and then\nitself encrypted, using three, 32-bit keys.  The key values are\ninitialized using the supplied encryption password.  After each byte\nis encrypted, the keys are then updated using pseudo-random number\ngeneration techniques in combination with the same CRC-32 algorithm\nused in PKZIP and described elsewhere in this document.\n\nThe following is the basic steps required to decrypt a file:\n\n1) Initialize the three 32-bit keys with the password.\n2) Read and decrypt the 12-byte encryption header, further\n   initializing the encryption keys.\n3) Read and decrypt the compressed data stream using the\n   encryption keys.\n\n\nStep 1 - Initializing the encryption keys\n-----------------------------------------\n\nKey(0) <- 305419896\nKey(1) <- 591751049\nKey(2) <- 878082192\n\nloop for i <- 0 to length(password)-1\n    update_keys(password(i))\nend loop\n\n\nWhere update_keys() is defined as:\n\n\nupdate_keys(char):\n  Key(0) <- crc32(key(0),char)\n  Key(1) <- Key(1) + (Key(0) & 000000ffH)\n  Key(1) <- Key(1) * 134775813 + 1\n  Key(2) <- crc32(key(2),key(1) >> 24)\nend update_keys\n\n\nWhere crc32(old_crc,char) is a routine that given a CRC value and a\ncharacter, returns an updated CRC value after applying the CRC-32\nalgorithm described elsewhere in this document.\n\n\nStep 2 - Decrypting the encryption header\n-----------------------------------------\n\nThe purpose of this step is to further initialize the encryption\nkeys, based on random data, to render a plaintext attack on the\ndata ineffective.\n\n\nRead the 12-byte encryption header into Buffer, in locations\nBuffer(0) thru Buffer(11).\n\nloop for i <- 0 to 11\n    C <- buffer(i) ^ decrypt_byte()\n    update_keys(C)\n    buffer(i) <- C\nend loop\n\n\nWhere decrypt_byte() is defined as:\n\n\nunsigned char decrypt_byte()\n    local unsigned short temp\n    temp <- Key(2) | 2\n    decrypt_byte <- (temp * (temp ^ 1)) >> 8\nend decrypt_byte\n\n\nAfter the header is decrypted,  the last 1 or 2 bytes in Buffer\nshould be the high-order word/byte of the CRC for the file being\ndecrypted, stored in Intel low-byte/high-byte order.  Versions of\nPKZIP prior to 2.0 used a 2 byte CRC check; a 1 byte CRC check is\nused on versions after 2.0.  This can be used to test if the password\nsupplied is correct or not.\n\n\nStep 3 - Decrypting the compressed data stream\n----------------------------------------------\n\nThe compressed data stream can be decrypted as follows:\n\n\nloop until done\n    read a charcter into C\n    Temp <- C ^ decrypt_byte()\n    update_keys(temp)\n    output Temp\nend loop\n\n\nIn addition to the above mentioned contributors to PKZIP and PKUNZIP,\nI would like to extend special thanks to Robert Mahoney for suggesting\nthe extension .ZIP for this software.\n\n\nReferences:\n\n    Fiala, Edward R., and Greene, Daniel H., \"Data compression with\n       finite windows\",  Communications of the ACM, Volume 32, Number 4,\n       April 1989, pages 490-505.\n\n    Held, Gilbert, \"Data Compression, Techniques and Applications,\n\t\t    Hardware and Software Considerations\",\n       John Wiley & Sons, 1987.\n\n    Huffman, D.A., \"A method for the construction of minimum-redundancy\n       codes\", Proceedings of the IRE, Volume 40, Number 9, September 1952,\n       pages 1098-1101.\n\n    Nelson, Mark, \"LZW Data Compression\", Dr. Dobbs Journal, Volume 14,\n       Number 10, October 1989, pages 29-37.\n\n    Nelson, Mark, \"The Data Compression Book\",  M&T Books, 1991.\n\n    Storer, James A., \"Data Compression, Methods and Theory\",\n       Computer Science Press, 1988\n\n    Welch, Terry, \"A Technique for High-Performance Data Compression\",\n       IEEE Computer, Volume 17, Number 6, June 1984, pages 8-19.\n\n    Ziv, J. and Lempel, A., \"A universal algorithm for sequential data\n       compression\", Communications of the ACM, Volume 30, Number 6,\n       June 1987, pages 520-540.\n\n    Ziv, J. and Lempel, A., \"Compression of individual sequences via\n       variable-rate coding\", IEEE Transactions on Information Theory,\n       Volume 24, Number 5, September 1978, pages 530-536.\n\n\n\n\n\n-- \n | Paul Lindner | lindner&boombox.micro.umn.edu   | Slipping into madness\n |              | Computer & Information Services | is good for the sake\n | Gophermaster | University of Minnesota         | of comparison.\n///// / / /    /////// / / / /  /  /  /   /      //// / / / /  /  /  /   /\n\n\n\n"
  },
  "references": []
}