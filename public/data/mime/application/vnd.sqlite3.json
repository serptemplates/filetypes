{
  "type": "application",
  "subtype": "vnd.sqlite3",
  "full": "application/vnd.sqlite3",
  "extensions": [],
  "sources": [
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    },
    {
      "source": "iana",
      "url": "https://www.iana.org/assignments/media-types/media-types.xhtml"
    },
    {
      "source": "apache",
      "url": "https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types"
    },
    {
      "source": "nginx",
      "url": "https://hg.nginx.org/nginx/raw-file/default/conf/mime.types"
    },
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    }
  ],
  "iana": {
    "template_url": "https://www.iana.org/assignments/media-types/application/vnd.sqlite3",
    "encoding_considerations": "binary",
    "security_considerations": "Database files contain complex data structures, so parsers must take\ncare to prevent buffer overflows, stack overruns, and other unexpected\nbehaviour caused by malicious content.\n\nViews and triggers can contain arbitrary SQL expressions (including\nrecursion), which can result in arbitrarily large amounts of\nprocessing time, memory, and disk space required when attempting to\naccess data. Applications should use mechanisms like\nsqlite3_interrupt() or sqlite3_progress_handler() to allow long\ncomputations to be aborted, and an alternative memory allocator to\nlimit the amount of memory used.\n\nThe SQLite library itself, as distributed, does not allow SQL\nstatements to access resources or data outside the database. However,\nif applications add extension modules or functions, they should not do\nso in the database connection used to access untrusted content, or\nthey must ensure that these modules/functions are safe to use even\nwhen called from malicious SQL code.\n\nThe database may leave part of deleted or updated data in the database\nfile. Applications that do not want ot leave traces of old data must\nenable PRAGMA secure_delete before doing any modifications, or run\nVACUUM before transmitting the database file.\n\nDatabases can use indexes to cache data in a format that is faster to\naccess for certain queries. It is possible to construct database\nfiles with inconsistent data in indexes so that some queries return\ndata different from what is actually stored in a table. To avoid\nthis, applications should run REINDEX before accessing a database\nreceived from a potentially malicious source.\n\nThis format provides no cryptographic integrity or confidentiality/\nprivacy protections of any kind.\n\nDatabases can be used to store blobs containing data to be handled by\nother applications or libraries; any security considerations of those\nmust also be taken into account.",
    "interoperability_considerations": "At publication of this document, there exists only a single\nimplementation, the SQLite library.\n\nThere exist various encryption extensions (e.g., SEE, SQLCipher,\nSystem.Data.SQLite), but they are incompatible with each other, so\nthey cannot be used for interoperable database files.\n\nDatabase files written with recent versions of the library can be read\nand modified by any version back to at least 3.7.0 (released\n2010-07-21). However, there is no backwards compatibility if SQL\nfeatures introduced in a newer version are actually used. To ensure\ninteroperability with other applications that use an older version of\nthe library, applications should avoid using features that are not\nsupported in the version that other applications are known or\nsuspected to use. At publication of this document, features\nintroduced in newer versions are:\n\n3.20.0: deterministic date/time functions;\n3.18.0: printf() thousands marks;\n3.16.0: PRAGMA functions;\n3.15.0: row values; deterministic SQL functions in partial indexes;\n3.9.0: expression indexes;\n3.8.8: more than 500 rows in a VALUES clause;\n3.8.6: hexadecimal integer literals; likely();\n3.8.3: common table expressions (WITH); printf();\n3.8.2: clustered indexes (WITHOUT ROWID tables);\n3.8.1: unlikely(); likelihood();\n3.8.0: partial indexes;\n3.7.16: unicode(); char();\n3.7.15: instr();\n3.7.11: multiple rows in a VALUES clause; bare columns in aggregate queries.\n\nSome runtime settings (e.g., PRAGMA case_sensitive_like) or\ncompilation options can change the semantics of SQL statements.\nApplications should use the default settings and options; however,\nsome settings (e.g., PRAGMA foreign_keys) are disabled by default only\nfor backwards compatibility and are commonly enabled.\n\nWhen a transaction that changes the database has not yet committed,\nthe database file might be in an inconsistent state and require data\nfrom the rollback journal to get back to a consistent state.\nTherefore, when it is possible that other processes or threads change\na database, an application that wishes to transmit a database file\nshould prevent concurrent changes by executing BEGIN IMMEDIATE before\nreading/copying the file, or use the backup API to create a consistent\ncopy of the database.\n\nA database in WAL mode can have part of its data in the WAL file.\nTherefore, an application that wishes to transmit a database file in\nWAL mode should initiate a full checkpoint before reading/copying the\nfile, or use the backup API to create a copy of the database.\n\nThe unregistered media type \"application/x-sqlite3\" must not be used,\nexcept where required for backwards compatibility.",
    "applications": "Applications that want to store or interchange relational data.",
    "template_text": "(registered 2018-02-12, last updated 2018-02-12)\n\nType name:\n\napplication\n\nSubtype name:\n\nvnd.sqlite3\n\nRequired parameters:\n\nnone\n\nOptional parameters:\n\nnone\n\nEncoding considerations:\n\nbinary\n\nSecurity considerations:\n\nDatabase files contain complex data structures, so parsers must take\ncare to prevent buffer overflows, stack overruns, and other unexpected\nbehaviour caused by malicious content.\n\nViews and triggers can contain arbitrary SQL expressions (including\nrecursion), which can result in arbitrarily large amounts of\nprocessing time, memory, and disk space required when attempting to\naccess data. Applications should use mechanisms like\nsqlite3_interrupt() or sqlite3_progress_handler() to allow long\ncomputations to be aborted, and an alternative memory allocator to\nlimit the amount of memory used.\n\nThe SQLite library itself, as distributed, does not allow SQL\nstatements to access resources or data outside the database. However,\nif applications add extension modules or functions, they should not do\nso in the database connection used to access untrusted content, or\nthey must ensure that these modules/functions are safe to use even\nwhen called from malicious SQL code.\n\nThe database may leave part of deleted or updated data in the database\nfile. Applications that do not want ot leave traces of old data must\nenable PRAGMA secure_delete before doing any modifications, or run\nVACUUM before transmitting the database file.\n\nDatabases can use indexes to cache data in a format that is faster to\naccess for certain queries. It is possible to construct database\nfiles with inconsistent data in indexes so that some queries return\ndata different from what is actually stored in a table. To avoid\nthis, applications should run REINDEX before accessing a database\nreceived from a potentially malicious source.\n\nThis format provides no cryptographic integrity or confidentiality/\nprivacy protections of any kind.\n\nDatabases can be used to store blobs containing data to be handled by\nother applications or libraries; any security considerations of those\nmust also be taken into account.\n\nInteroperability considerations:\n\nAt publication of this document, there exists only a single\nimplementation, the SQLite library.\n\nThere exist various encryption extensions (e.g., SEE, SQLCipher,\nSystem.Data.SQLite), but they are incompatible with each other, so\nthey cannot be used for interoperable database files.\n\nDatabase files written with recent versions of the library can be read\nand modified by any version back to at least 3.7.0 (released\n2010-07-21). However, there is no backwards compatibility if SQL\nfeatures introduced in a newer version are actually used. To ensure\ninteroperability with other applications that use an older version of\nthe library, applications should avoid using features that are not\nsupported in the version that other applications are known or\nsuspected to use. At publication of this document, features\nintroduced in newer versions are:\n\n3.20.0: deterministic date/time functions;\n3.18.0: printf() thousands marks;\n3.16.0: PRAGMA functions;\n3.15.0: row values; deterministic SQL functions in partial indexes;\n3.9.0: expression indexes;\n3.8.8: more than 500 rows in a VALUES clause;\n3.8.6: hexadecimal integer literals; likely();\n3.8.3: common table expressions (WITH); printf();\n3.8.2: clustered indexes (WITHOUT ROWID tables);\n3.8.1: unlikely(); likelihood();\n3.8.0: partial indexes;\n3.7.16: unicode(); char();\n3.7.15: instr();\n3.7.11: multiple rows in a VALUES clause; bare columns in aggregate queries.\n\nSome runtime settings (e.g., PRAGMA case_sensitive_like) or\ncompilation options can change the semantics of SQL statements.\nApplications should use the default settings and options; however,\nsome settings (e.g., PRAGMA foreign_keys) are disabled by default only\nfor backwards compatibility and are commonly enabled.\n\nWhen a transaction that changes the database has not yet committed,\nthe database file might be in an inconsistent state and require data\nfrom the rollback journal to get back to a consistent state.\nTherefore, when it is possible that other processes or threads change\na database, an application that wishes to transmit a database file\nshould prevent concurrent changes by executing BEGIN IMMEDIATE before\nreading/copying the file, or use the backup API to create a consistent\ncopy of the database.\n\nA database in WAL mode can have part of its data in the WAL file.\nTherefore, an application that wishes to transmit a database file in\nWAL mode should initiate a full checkpoint before reading/copying the\nfile, or use the backup API to create a copy of the database.\n\nThe unregistered media type \"application/x-sqlite3\" must not be used,\nexcept where required for backwards compatibility.\n\nPublished specification:\n\nhttp://www.sqlite.org/fileformat2.html\nhttp://www.sqlite.org/lang.html\n\nApplications that use this media type:\n\nApplications that want to store or interchange relational data.\n\nFragment identifier considerations:\n\nnone\n\nDeprecated alias names for this type:\n\napplication/x-sqlite3\n\nMagic number:\n\n53 51 4c 69 74 65 20 66 6f 72 6d 61 74 20 33 00\n(zero-terminated ASCII \"SQLite format 3\") at offset 0\n\nFile extensions:\n\n.db, .sqlite, .sqlite3\n(\".db\" does not uniquely identify SQLite database files.\nOther extensions are commonly used.)\n\nMacintosh file type code:\n\nnone\n\nContact:\n\nSQLite mailing list\n<sqlite-users&mailinglists.sqlite.org>\n\nIntended usage:\n\nCOMMON\n\nRestrictions on usage:\n\nnone\n\nAuthor/Change controller:\n\nClemens Ladisch\n<clemens&ladisch.de>\n\nProvisional registration? (standards tree only):\n\nN/A"
  },
  "references": []
}