{
  "type": "model",
  "subtype": "vnd.bary",
  "full": "model/vnd.bary",
  "extensions": [
    "bary"
  ],
  "sources": [
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    },
    {
      "source": "iana",
      "url": "https://www.iana.org/assignments/media-types/media-types.xhtml"
    },
    {
      "source": "apache",
      "url": "https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types"
    },
    {
      "source": "nginx",
      "url": "https://hg.nginx.org/nginx/raw-file/default/conf/mime.types"
    },
    {
      "source": "mime-db",
      "url": "https://www.npmjs.com/package/mime-db"
    }
  ],
  "iana": {
    "template_url": "https://www.iana.org/assignments/media-types/model/vnd.bary",
    "encoding_considerations": "Security considerations: This media type does not contain active or \n   executable content.\n\n   The information contained in the media type does not need privacy \n   or integrity services. No integrity validation is available in \n   BARY's standard properties; if you require this for your \n   application, consider using BARY's extension mechanisms to add a \n   new property containing the required data.\n\n   Always validate BARY data before reading it if it is not already \n   known to be valid.\n\n   When accessing BARY byte ranges, check that the start and end of \n   the range are within the bounds of the BARY file.\n\n   When overwriting a BARY file with new or modified data, the file \n   truncation flag (if available) should be used when creating the \n   file, to ensure any previous data is overwritten.\n\n   When adding padding to align buffers, ensure padding is \n   initialized (for instance, set each octet in the padding to 0). \n   Uninitialized data can contain information from prior allocations \n   and should be overwritten.\n\n   When decompressing supercompressed data in BARY files, check that \n   the uncompressed data size (stored with supercompression \n   information) is within reasonable limits to avoid resource \n   exhaustion.\n\n   If you are developing a new BARY reader or writer, consider \n   fuzz-testing it with a tool such as libFuzzer. An example read and \n   write fuzzer target is available as part of the NVIDIA® BARY \n   library.\n\n   Non-standard (custom) BARY properties may have additional security \n   considerations, as the standard implementation of the validation \n   would not cover them.\n\nInteroperability considerations: BARY is cross-platform and stores \n   integers using little-endian.\n\n   The BARY file format is versioned using semantic versioning. The \n   version of the file format is stored in the 16-octet version \n   identifier that starts BARY data. For more information, please see \n   Other Information and Comments below.\n\nPublished specification: The BARY reference implementation and \n   pattern file is available at\n   https://github.com/NVIDIAGameWorks/Displacement-MicroMap-BaryFile\n\n   No formal specification is available as of this writing.\n\nApplications which use this media: BARY is used in the NVIDIA® \n   Displacement Micro-Map Toolkit, NVIDIA Omniverse™, and the \n   Simplygon™ SDK to store data for micro-meshes. An open-source SDK \n   is available to add BARY to custom applications. Additionally, \n   BARY can be used with the NV_micromap glTF extension and the USD \n   BarycentricFileAPI schema.\n\nFragment identifier considerations: N/A\n\nRestrictions on usage: N/A",
    "security_considerations": "executable content.\n\n   The information contained in the media type does not need privacy \n   or integrity services. No integrity validation is available in \n   BARY's standard properties; if you require this for your \n   application, consider using BARY's extension mechanisms to add a \n   new property containing the required data.\n\n   Always validate BARY data before reading it if it is not already \n   known to be valid.\n\n   When accessing BARY byte ranges, check that the start and end of \n   the range are within the bounds of the BARY file.\n\n   When overwriting a BARY file with new or modified data, the file \n   truncation flag (if available) should be used when creating the \n   file, to ensure any previous data is overwritten.\n\n   When adding padding to align buffers, ensure padding is \n   initialized (for instance, set each octet in the padding to 0). \n   Uninitialized data can contain information from prior allocations \n   and should be overwritten.\n\n   When decompressing supercompressed data in BARY files, check that \n   the uncompressed data size (stored with supercompression \n   information) is within reasonable limits to avoid resource \n   exhaustion.\n\n   If you are developing a new BARY reader or writer, consider \n   fuzz-testing it with a tool such as libFuzzer. An example read and \n   write fuzzer target is available as part of the NVIDIA® BARY \n   library.\n\n   Non-standard (custom) BARY properties may have additional security \n   considerations, as the standard implementation of the validation \n   would not cover them.\n\nInteroperability considerations: BARY is cross-platform and stores \n   integers using little-endian.\n\n   The BARY file format is versioned using semantic versioning. The \n   version of the file format is stored in the 16-octet version \n   identifier that starts BARY data. For more information, please see \n   Other Information and Comments below.\n\nPublished specification: The BARY reference implementation and \n   pattern file is available at\n   https://github.com/NVIDIAGameWorks/Displacement-MicroMap-BaryFile\n\n   No formal specification is available as of this writing.\n\nApplications which use this media: BARY is used in the NVIDIA® \n   Displacement Micro-Map Toolkit, NVIDIA Omniverse™, and the \n   Simplygon™ SDK to store data for micro-meshes. An open-source SDK \n   is available to add BARY to custom applications. Additionally, \n   BARY can be used with the NV_micromap glTF extension and the USD \n   BarycentricFileAPI schema.\n\nFragment identifier considerations: N/A\n\nRestrictions on usage: N/A",
    "interoperability_considerations": "integers using little-endian.\n\n   The BARY file format is versioned using semantic versioning. The \n   version of the file format is stored in the 16-octet version \n   identifier that starts BARY data. For more information, please see \n   Other Information and Comments below.\n\nPublished specification: The BARY reference implementation and \n   pattern file is available at\n   https://github.com/NVIDIAGameWorks/Displacement-MicroMap-BaryFile\n\n   No formal specification is available as of this writing.\n\nApplications which use this media: BARY is used in the NVIDIA® \n   Displacement Micro-Map Toolkit, NVIDIA Omniverse™, and the \n   Simplygon™ SDK to store data for micro-meshes. An open-source SDK \n   is available to add BARY to custom applications. Additionally, \n   BARY can be used with the NV_micromap glTF extension and the USD \n   BarycentricFileAPI schema.\n\nFragment identifier considerations: N/A\n\nRestrictions on usage: N/A",
    "additional_information": "1. Deprecated alias names for this type: N/A\n   2. Magic number(s): 6 octets { 0xAB 0x42 0x41 0x52 0x59 0x20 }\n   3. File extension(s): .bary\n   4. Macintosh file type code: N/A\n   5. Object Identifiers: N/A\n\nGeneral Comments: BARY data starts with a 16-octet version \n   identifier. This consists of BARY's 6-octet magic number (octets \n   0xAB 0x42 0x41 0x52 0x59 0x20), followed by five octets \n   representing ASCII digits, followed by the five octets 0xBB 0x0D \n   0x0A 0x1A 0x0A.\n\n   These five ASCII digits, when interpreted as a 5-digit integer, \n   store the version of the BARY format in 100*major + minor format \n   (0 <= minor < 100). For instance, the five ASCII digits 00100 \n   ({0x30 0x30 0x31 0x30 0x30}) indicate BARY version 1.0. A version \n   identifier where the five digits were 12345 ({0x31 0x32 0x33 0x34 \n   0x35}) would indicate BARY format version 123.45.\n\n   The values in this version identifier were chosen for the \n   following properties, based on the KTX version 2 file identifier:\n\n   Octet 0 is a non-ASCII value, which reduces the chance of BARY \n   files being interpreted as text. It also catches data transfers \n   that may clear bit 7.\n\n   Octets 1 through and including 5 are the ASCII values for the \n   string \"BARY \", including a trailing space. As a result, this part \n   of the version identifier combined with the five ASCII digits for \n   BARY 1.0 reads \"BARY 00100\".\n\n   Octet 11 is for aesthetic balance with octet 1; they are a \n   matching pair of double-angle quotation marks when interpreted as \n   UTF-8 code points.\n\n   Octets 12 and 13 form a CR-LF sequence, which captures data \n   transfers that alter newline sequences.\n\n   Octet 14 is a control-Z character, which stops file display under \n   MS-DOS.\n\n   Octet 15 is a final line feed, which checks for data transfers \n   that turn line feeds without carriage returns into CR-LF sequences.",
    "intended_usage": "common",
    "template_text": "(registered 2023-03-23, last updated 2023-03-23)\n\nMedia type name: model\n\nMedia subtype name: vnd.bary\n\nRequired parameters: N/A\n\nOptional parameters: N/A\n\nEncoding considerations: binary\n\nSecurity considerations: This media type does not contain active or \n   executable content.\n\n   The information contained in the media type does not need privacy \n   or integrity services. No integrity validation is available in \n   BARY's standard properties; if you require this for your \n   application, consider using BARY's extension mechanisms to add a \n   new property containing the required data.\n\n   Always validate BARY data before reading it if it is not already \n   known to be valid.\n\n   When accessing BARY byte ranges, check that the start and end of \n   the range are within the bounds of the BARY file.\n\n   When overwriting a BARY file with new or modified data, the file \n   truncation flag (if available) should be used when creating the \n   file, to ensure any previous data is overwritten.\n\n   When adding padding to align buffers, ensure padding is \n   initialized (for instance, set each octet in the padding to 0). \n   Uninitialized data can contain information from prior allocations \n   and should be overwritten.\n\n   When decompressing supercompressed data in BARY files, check that \n   the uncompressed data size (stored with supercompression \n   information) is within reasonable limits to avoid resource \n   exhaustion.\n\n   If you are developing a new BARY reader or writer, consider \n   fuzz-testing it with a tool such as libFuzzer. An example read and \n   write fuzzer target is available as part of the NVIDIA® BARY \n   library.\n\n   Non-standard (custom) BARY properties may have additional security \n   considerations, as the standard implementation of the validation \n   would not cover them.\n\nInteroperability considerations: BARY is cross-platform and stores \n   integers using little-endian.\n\n   The BARY file format is versioned using semantic versioning. The \n   version of the file format is stored in the 16-octet version \n   identifier that starts BARY data. For more information, please see \n   Other Information and Comments below.\n\nPublished specification: The BARY reference implementation and \n   pattern file is available at\n   https://github.com/NVIDIAGameWorks/Displacement-MicroMap-BaryFile\n\n   No formal specification is available as of this writing.\n\nApplications which use this media: BARY is used in the NVIDIA® \n   Displacement Micro-Map Toolkit, NVIDIA Omniverse™, and the \n   Simplygon™ SDK to store data for micro-meshes. An open-source SDK \n   is available to add BARY to custom applications. Additionally, \n   BARY can be used with the NV_micromap glTF extension and the USD \n   BarycentricFileAPI schema.\n\nFragment identifier considerations: N/A\n\nRestrictions on usage: N/A\n\nAdditional information:\n\n   1. Deprecated alias names for this type: N/A\n   2. Magic number(s): 6 octets { 0xAB 0x42 0x41 0x52 0x59 0x20 }\n   3. File extension(s): .bary\n   4. Macintosh file type code: N/A\n   5. Object Identifiers: N/A\n\nGeneral Comments: BARY data starts with a 16-octet version \n   identifier. This consists of BARY's 6-octet magic number (octets \n   0xAB 0x42 0x41 0x52 0x59 0x20), followed by five octets \n   representing ASCII digits, followed by the five octets 0xBB 0x0D \n   0x0A 0x1A 0x0A.\n\n   These five ASCII digits, when interpreted as a 5-digit integer, \n   store the version of the BARY format in 100*major + minor format \n   (0 <= minor < 100). For instance, the five ASCII digits 00100 \n   ({0x30 0x30 0x31 0x30 0x30}) indicate BARY version 1.0. A version \n   identifier where the five digits were 12345 ({0x31 0x32 0x33 0x34 \n   0x35}) would indicate BARY format version 123.45.\n\n   The values in this version identifier were chosen for the \n   following properties, based on the KTX version 2 file identifier:\n\n   Octet 0 is a non-ASCII value, which reduces the chance of BARY \n   files being interpreted as text. It also catches data transfers \n   that may clear bit 7.\n\n   Octets 1 through and including 5 are the ASCII values for the \n   string \"BARY \", including a trailing space. As a result, this part \n   of the version identifier combined with the five ASCII digits for \n   BARY 1.0 reads \"BARY 00100\".\n\n   Octet 11 is for aesthetic balance with octet 1; they are a \n   matching pair of double-angle quotation marks when interpreted as \n   UTF-8 code points.\n\n   Octets 12 and 13 form a CR-LF sequence, which captures data \n   transfers that alter newline sequences.\n\n   Octet 14 is a control-Z character, which stops file display under \n   MS-DOS.\n\n   Octet 15 is a final line feed, which checks for data transfers \n   that turn line feeds without carriage returns into CR-LF sequences.\n\nPerson to contact for further information:\n\n   1. Name: Displaced Micro-Mesh SDK Support\n   2. Email: DisplacedMicroMesh-SDK-support&nvidia.com\n\nIntended usage: COMMON\n\n   BARY is a format designed for data sampled with barycentric \n   coordinates over meshes. For instance, it can be used as a \n   micro-map format: to store micro-triangle opacity for Opacity \n   Micro-Meshes, micro-vertex displacements for Displaced \n   Micro-Meshes, or other attributes such as micro-vertex colors.\n\n   In addition to a set of standard properties (which are 128-bit \n   identifiers together with a byte range to binary data and \n   supercompression information), BARY files can be extended to add \n   custom properties.\n\n   Although BARY can optionally store base mesh positions using the \n   eMeshPositions and eMeshTriangleIndices standard properties, the \n   eMeshPositions and eMeshTriangleIndices properties are not \n   intended as a standalone format for base meshes. They are intended \n   to provide a way to determine which BARY file(s) a mesh uses if \n   the correspondence between the two is lost. They can also be \n   useful for debugging.\n\nAuthor/Change controller: \n\n   NVIDIA Corporation\n   Christoph Kubisch (ckubisch&nvidia.com)\n   Neil Bickford (nbickford&nvidia.com)\n"
  },
  "references": []
}